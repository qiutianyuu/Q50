import pandas as pd
import numpy as np
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# ‰∫§ÊòìÊàêÊú¨ÈÖçÁΩÆ
FEE_RATE = 0.0004  # Binance taker fee 0.04%
SLIPPAGE = 0.0002  # 0.02% ÊªëÁÇπ
TOTAL_COST = FEE_RATE * 2 + SLIPPAGE  # ÂèåÂêë‰∫§ÊòìÊÄªÊàêÊú¨

def load_data():
    """Âä†ËΩΩ5ÂàÜÈíüÊï∞ÊçÆ"""
    try:
        # Â∞ùËØïÂä†ËΩΩ5ÊúàÊï∞ÊçÆ
        df = pd.read_csv('/Users/qiutianyu/ETHUSDT-5m-2025-05/ETHUSDT-5m-2025-05.csv', header=None)
        print(f"‚úÖ ÊàêÂäüÂä†ËΩΩÊï∞ÊçÆ: {len(df)} Ë°å")
    except FileNotFoundError:
        print("‚ùå Êâæ‰∏çÂà∞5ÊúàÊï∞ÊçÆÊñá‰ª∂")
        return None
    
    # ËÆæÁΩÆÂàóÂêç - Ê†πÊçÆÂÆûÈôÖÊï∞ÊçÆÁªìÊûÑ
    df.columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume', 
                  'close_time', 'quote_volume', 'trades', 'taker_buy_base', 
                  'taker_buy_quote', 'ignore']
    
    # Âè™‰øùÁïôÈúÄË¶ÅÁöÑÂàó
    df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]
    # ‰øÆÊ≠£Êó∂Èó¥Êà≥‰∏∫ÊØ´Áßí
    df['timestamp'] = pd.to_datetime((df['timestamp'] // 1_000_000).astype(int), unit='ms')
    df = df.sort_values('timestamp').reset_index(drop=True)
    
    return df

def calculate_indicators(df):
    """ËÆ°ÁÆóÊäÄÊúØÊåáÊ†á"""
    # RSI
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['rsi'] = 100 - (100 / (1 + rs))
    
    # MACD
    exp1 = df['close'].ewm(span=12).mean()
    exp2 = df['close'].ewm(span=26).mean()
    df['macd'] = exp1 - exp2
    df['macd_signal'] = df['macd'].ewm(span=9).mean()
    df['macd_hist'] = df['macd'] - df['macd_signal']
    
    # Bollinger Bands
    df['bb_middle'] = df['close'].rolling(window=20).mean()
    bb_std = df['close'].rolling(window=20).std()
    df['bb_upper'] = df['bb_middle'] + (bb_std * 2)
    df['bb_lower'] = df['bb_middle'] - (bb_std * 2)
    df['bb_width'] = (df['bb_upper'] - df['bb_lower']) / df['bb_middle']
    
    # Stochastic
    low_min = df['low'].rolling(window=14).min()
    high_max = df['high'].rolling(window=14).max()
    df['stoch_k'] = 100 * ((df['close'] - low_min) / (high_max - low_min))
    df['stoch_d'] = df['stoch_k'].rolling(window=3).mean()
    
    # ATR
    high_low = df['high'] - df['low']
    high_close = np.abs(df['high'] - df['close'].shift())
    low_close = np.abs(df['low'] - df['close'].shift())
    ranges = pd.concat([high_low, high_close, low_close], axis=1)
    true_range = ranges.max(axis=1)
    df['atr'] = true_range.rolling(window=14).mean()
    
    # OBV
    df['obv'] = (np.sign(df['close'].diff()) * df['volume']).fillna(0).cumsum()
    
    # Dynamic Vitality
    df['vitality'] = (df['close'] - df['close'].shift(5)) / df['close'].shift(5)
    
    # Momentum
    df['momentum'] = df['close'] / df['close'].shift(10) - 1
    
    # Volatility
    df['volatility'] = df['close'].rolling(window=20).std() / df['close'].rolling(window=20).mean()
    
    # Trend Strength
    df['trend_strength'] = abs(df['close'] - df['close'].shift(20)) / df['close'].shift(20)
    
    # ÁßªÂä®Âπ≥Âùá
    df['ma_20'] = df['close'].rolling(window=20).mean()
    df['ma_50'] = df['close'].rolling(window=50).mean()
    
    # È¢ÑËÆ°ÁÆóÊªöÂä®ÂùáÂÄº‰ª•ÈÅøÂÖçÂæ™ÁéØ‰∏≠ÁöÑËÆ°ÁÆó
    df['vol_ma'] = df['volume'].rolling(window=20).mean()
    df['vitality_ma'] = df['vitality'].rolling(window=20).mean()
    
    return df

def generate_signals(df):
    """ÁîüÊàê‰∫§Êòì‰ø°Âè∑"""
    signals = []
    position = None
    entry_price = None
    entry_time = None
    capital = 50000
    trades = []
    
    for i in range(50, len(df)):
        row = df.iloc[i]
        
        # Ë∑≥ËøáÁº∫Â§±ÂÄº
        if pd.isna(row['rsi']) or pd.isna(row['macd']) or pd.isna(row['atr']):
            continue
            
        # Â§öÁ©∫Êù°‰ª∂Ê£ÄÊü•
        long_conditions = 0
        short_conditions = 0
        
        # 1. RSIÊù°‰ª∂
        if row['rsi'] < 30:
            long_conditions += 1
        elif row['rsi'] > 70:
            short_conditions += 1
            
        # 2. MACDÊù°‰ª∂
        if row['macd'] > row['macd_signal'] and row['macd_hist'] > 0:
            long_conditions += 1
        elif row['macd'] < row['macd_signal'] and row['macd_hist'] < 0:
            short_conditions += 1
            
        # 3. Bollinger BandsÊù°‰ª∂
        if row['close'] < row['bb_lower']:
            long_conditions += 1
        elif row['close'] > row['bb_upper']:
            short_conditions += 1
            
        # 4. StochasticÊù°‰ª∂
        if row['stoch_k'] < 20:
            long_conditions += 1
        elif row['stoch_k'] > 80:
            short_conditions += 1
            
        # 5. Êàê‰∫§ÈáèÊù°‰ª∂
        if row['volume'] > row['vol_ma'] * 1.2:
            if long_conditions > short_conditions:
                long_conditions += 1
            elif short_conditions > long_conditions:
                short_conditions += 1
                
        # 6. VitalityÊù°‰ª∂
        if row['vitality'] > row['vitality_ma'] * 1.1:
            if long_conditions > short_conditions:
                long_conditions += 1
            elif short_conditions > long_conditions:
                short_conditions += 1
                
        # 7. Ë∂ãÂäøÂº∫Â∫¶Êù°‰ª∂
        if row['trend_strength'] > 0.05:
            if long_conditions > short_conditions:
                long_conditions += 1
            elif short_conditions > long_conditions:
                short_conditions += 1
        
        # ‰ø°Âè∑ÁîüÊàêÈÄªËæë
        signal = None
        if long_conditions >= 4 and position != 'long':
            signal = 'long'
        elif short_conditions >= 4 and position != 'short':
            signal = 'short'
        elif position == 'long' and (short_conditions >= 3 or row['close'] < entry_price * 0.99):
            signal = 'close_long'
        elif position == 'short' and (long_conditions >= 3 or row['close'] > entry_price * 1.01):
            signal = 'close_short'
            
        # ÊâßË°å‰∫§Êòì
        if signal:
            if signal == 'long' and position is None:
                position = 'long'
                entry_price = row['close']
                entry_time = row['timestamp']
                print(f"üü¢ ÂºÄÂ§ö: {row['timestamp']} @ {entry_price:.2f}")
                
            elif signal == 'short' and position is None:
                position = 'short'
                entry_price = row['close']
                entry_time = row['timestamp']
                print(f"üî¥ ÂºÄÁ©∫: {row['timestamp']} @ {entry_price:.2f}")
                
            elif signal == 'close_long' and position == 'long':
                # ËÆ°ÁÆóÂéüÂßãPnL
                raw_pnl = (row['close'] - entry_price) / entry_price
                # Êâ£Èô§‰∫§ÊòìÊàêÊú¨
                net_pnl = raw_pnl - TOTAL_COST
                capital *= (1 + net_pnl)
                
                trades.append({
                    'entry_time': entry_time,
                    'exit_time': row['timestamp'],
                    'entry_price': entry_price,
                    'exit_price': row['close'],
                    'position': 'long',
                    'raw_pnl': raw_pnl,
                    'net_pnl': net_pnl,
                    'capital': capital,
                    'cost_paid': TOTAL_COST * capital
                })
                
                print(f"üü¢ Âπ≥Â§ö: {row['timestamp']} @ {row['close']:.2f} | PnL: {raw_pnl*100:.2f}% | ÂáÄPnL: {net_pnl*100:.2f}% | ËµÑÈáë: {capital:.2f}")
                
                position = None
                entry_price = None
                entry_time = None
                
            elif signal == 'close_short' and position == 'short':
                # ËÆ°ÁÆóÂéüÂßãPnL
                raw_pnl = (entry_price - row['close']) / entry_price
                # Êâ£Èô§‰∫§ÊòìÊàêÊú¨
                net_pnl = raw_pnl - TOTAL_COST
                capital *= (1 + net_pnl)
                
                trades.append({
                    'entry_time': entry_time,
                    'exit_time': row['timestamp'],
                    'entry_price': entry_price,
                    'exit_price': row['close'],
                    'position': 'short',
                    'raw_pnl': raw_pnl,
                    'net_pnl': net_pnl,
                    'capital': capital,
                    'cost_paid': TOTAL_COST * capital
                })
                
                print(f"üî¥ Âπ≥Á©∫: {row['timestamp']} @ {row['close']:.2f} | PnL: {raw_pnl*100:.2f}% | ÂáÄPnL: {net_pnl*100:.2f}% | ËµÑÈáë: {capital:.2f}")
                
                position = None
                entry_price = None
                entry_time = None
    
    return trades, capital

def analyze_results(trades, final_capital):
    """ÂàÜÊûêÂõûÊµãÁªìÊûú"""
    if not trades:
        print("‚ùå Ê≤°Êúâ‰∫§ÊòìËÆ∞ÂΩï")
        return
        
    df_trades = pd.DataFrame(trades)
    
    # Âü∫Á°ÄÁªüËÆ°
    total_trades = len(trades)
    winning_trades = len(df_trades[df_trades['net_pnl'] > 0])
    losing_trades = len(df_trades[df_trades['net_pnl'] < 0])
    win_rate = winning_trades / total_trades if total_trades > 0 else 0
    
    # Êî∂ÁõäÁªüËÆ°
    total_return = (final_capital - 50000) / 50000
    avg_win = df_trades[df_trades['net_pnl'] > 0]['net_pnl'].mean() if winning_trades > 0 else 0
    avg_loss = df_trades[df_trades['net_pnl'] < 0]['net_pnl'].mean() if losing_trades > 0 else 0
    
    # È£éÈô©ÁªüËÆ°
    returns = df_trades['net_pnl'].values
    volatility = np.std(returns) * np.sqrt(252 * 288)  # Âπ¥ÂåñÊ≥¢Âä®Áéá (5ÂàÜÈíüÊï∞ÊçÆ)
    sharpe_ratio = (np.mean(returns) * 252 * 288) / volatility if volatility > 0 else 0
    
    # ÊúÄÂ§ßÂõûÊí§
    capital_curve = [50000] + [trade['capital'] for trade in trades]
    peak = capital_curve[0]
    max_drawdown = 0
    for capital in capital_curve:
        if capital > peak:
            peak = capital
        drawdown = (peak - capital) / peak
        if drawdown > max_drawdown:
            max_drawdown = drawdown
    
    # ÊàêÊú¨ÂàÜÊûê
    total_cost = df_trades['cost_paid'].sum()
    total_raw_return = df_trades['raw_pnl'].sum()
    total_net_return = df_trades['net_pnl'].sum()
    
    print("\n" + "="*60)
    print("üìä REXKING Á≠ñÁï•ÂõûÊµãÁªìÊûú (Âê´‰∫§ÊòìÊàêÊú¨)")
    print("="*60)
    print(f"üí∞ ÂàùÂßãËµÑÈáë: $50,000")
    print(f"üí∞ ÊúÄÁªàËµÑÈáë: ${final_capital:,.2f}")
    print(f"üìà ÊÄªÊî∂ÁõäÁéá: {total_return*100:.2f}%")
    print(f"üìà ÊúàÂåñÊî∂ÁõäÁéá: {total_return*100:.2f}%")
    print(f"üîÑ ÊÄª‰∫§ÊòìÊ¨°Êï∞: {total_trades}")
    print(f"‚úÖ ÁõàÂà©‰∫§Êòì: {winning_trades}")
    print(f"‚ùå ‰∫èÊçü‰∫§Êòì: {losing_trades}")
    print(f"üéØ ËÉúÁéá: {win_rate*100:.1f}%")
    print(f"üìä Âπ≥ÂùáÁõàÂà©: {avg_win*100:.3f}%")
    print(f"üìä Âπ≥Âùá‰∫èÊçü: {avg_loss*100:.3f}%")
    print(f"‚ö° Â§èÊôÆÊØîÁéá: {sharpe_ratio:.2f}")
    print(f"üìâ ÊúÄÂ§ßÂõûÊí§: {max_drawdown*100:.2f}%")
    print(f"üí∏ ÊÄª‰∫§ÊòìÊàêÊú¨: ${total_cost:,.2f}")
    print(f"üí∏ ÊàêÊú¨Âç†ÊØî: {total_cost/50000*100:.2f}%")
    print(f"üìä ÂéüÂßãÊî∂Áõä: {total_raw_return*100:.2f}%")
    print(f"üìä ÂáÄÊî∂Áõä: {total_net_return*100:.2f}%")
    print(f"üí∏ ÊàêÊú¨‰æµËöÄ: {(total_raw_return - total_net_return)*100:.2f}%")
    
    # ‰øùÂ≠ò‰∫§ÊòìËÆ∞ÂΩï
    df_trades.to_csv('rexking_cost_analysis_trades.csv', index=False)
    print(f"\nüíæ ‰∫§ÊòìËÆ∞ÂΩïÂ∑≤‰øùÂ≠òÂà∞: rexking_cost_analysis_trades.csv")
    
    return df_trades

def main():
    print("üöÄ ÂºÄÂßã RexKing Á≠ñÁï•ÂõûÊµã (Âê´‰∫§ÊòìÊàêÊú¨)")
    print(f"üí∏ ‰∫§ÊòìÊàêÊú¨ËÆæÁΩÆ: {TOTAL_COST*100:.3f}% (ÂèåÂêë)")
    
    # Âä†ËΩΩÊï∞ÊçÆ
    df = load_data()
    if df is None:
        return
    
    # ËÆ°ÁÆóÊåáÊ†á
    print("üìä ËÆ°ÁÆóÊäÄÊúØÊåáÊ†á...")
    df = calculate_indicators(df)
    
    # ÁîüÊàê‰ø°Âè∑Âπ∂ÂõûÊµã
    print("üéØ ÁîüÊàê‰∫§Êòì‰ø°Âè∑...")
    trades, final_capital = generate_signals(df)
    
    # ÂàÜÊûêÁªìÊûú
    analyze_results(trades, final_capital)

if __name__ == "__main__":
    main() 